---
title: "Gynandromorph Pipeline and SNP Analysis"
output: html_document
date: "2024-11-19"
bibliography: citations.bib 
link-citations: TRUE
---

Since March 2024, a Snakemake pipeline has been in development to aid in analysis of a Heliconius melponome gynandromorph specimen. The following document will first provide a high level understanding of the pipeline, and then delve deeper into the specific Snakemake rules and analysis techniques. 



Snakemake provides a visual representation of rule dependencies and the pipeline flow:

![PIPELINE DAG](images\dag.png)

The pipeline executes the following steps in order:


1. BWA Align

2. Alignment Quality Control

3. Plot Coverage

4. Variant Calling

5. Variant Quality Control

6. Targets




# <span style="font-size: 130%;"> STEP 1: BWA Align </span>

The goal of BWA Align is to index the reference genome, align paired-end reads, and creates BAM files for each of the four legs.


The following code is used in Step 1, with the script "alignment.sh."
```{r, eval=FALSE}
#!/bin/bash
#SBATCH --mem=200G
#SBATCH -c32
#SBATCH --mail-type=END
#SBATCH --mail-user=shriya.minocha@duke.edu
REF=$1
r1=$2
r2=$3
sample=$4
module load BWA/0.7.17
module load samtools/1.9
bwa index ${REF}
samtools faidx ${REF}
bwa mem -M -t 32 "${REF}" ${r1} ${r2} | samtools sort -@32 -o ${sample}.bam
samtools index ${sample}.bam -@32
```





## <span style="font-size: 130%;"> STEP 2: Alignment Quality Control </span>

The goal of Alignment Quality Control is to removes duplicate sequences using the Picard module and to generates stats such as # of reads and read quality.

The following code is used in Step 2, with the script "qc_alignment.sh."

```{r, eval=FALSE}
#!/bin/sh
#SBATCH --mem=16G

leg=$1
module load Java/1.8.0_60
module load samtools/1.9

#marking duplicates
echo "Processing sample: $leg"
java -jar -Xmx7g /hpc/group/wraylab/kp275/team_heliconius/picard.jar MarkDuplicates -INPUT $leg -OUTPUT ${leg}.dedup.bam -METRICS_FILE metrics.txt -VALIDATION_STRINGENCY LENIENT


file="${leg}.dedup.bam"


echo "Output file: ${leg}.dedup.bam"

#generating bam statistics
samtools flagstat ${leg}.dedup.bam
samtools index ${leg}.dedup.bam
```

samtools.flagstat was used to do a  quality check of the deduplicated bam files. These are the results for TN2L_S1.bam.dedup.bam.


```{r, eval=FALSE}
samtools flagstat TN2L_S1.bam.dedup.bam
```
56997586 + 0 in total (QC-passed reads + QC-failed reads)
2146542 + 0 secondary
0 + 0 supplementary
4967653 + 0 duplicates
53068116 + 0 mapped (93.11% : N/A)
54851044 + 0 paired in sequencing
27425522 + 0 read1
27425522 + 0 read2
45302230 + 0 properly paired (82.59% : N/A)
50185440 + 0 with itself and mate mapped
736134 + 0 singletons (1.34% : N/A)
4161666 + 0 with mate mapped to a different chr
2176897 + 0 with mate mapped to a different chr (mapQ>=5)



As we can see, the number of duplicates has reduced down to 0, signalling that the deduplication rule worked as intended.





## <span style="font-size: 130%;"> STEP 3: Coverage Plot </span>

By generating a coverage plot of the indexed BAM files, we can gain more information about the distribution of sex chromosomes within the gynadromorph specimin.

The following code is used in Step 2, with the script "plotcov.sh."

```{r, eval = FALSE}
#!/bin/sh

module load Java/1.8.0_60
module load samtools/1.9

samtools index $1
samtools index $2
samtools index $3
samtools index $4
plotCoverage -b $1 $2 $3 $4 -o dedup_cov.png
```

Here is the coverage plot generated by the pipeline:

![Coverage Plot](images\dedup_cov.png)



## <span style="font-size: 130%;"> STEP 4: Variant Calling </span>

The goal of Variant Calling is to use GATK to locate potential SNPs and generates VCFs for all four legs genomes. This step will generate two types of VCFs: per sample VCFs, and joint called VCFs. 


The following code is used in Step 4 Part 1, with the script "per_sample_variant_calling.sh."

```{r, eval=FALSE}
#!/bin/bash
#SBATCH --mem=100G
#SBATCH --cpus-per-task 24
#SBATCH --partition scavenger

samtools index ${1}.bam.dedup.bam

echo singularity exec -B /hpc/group/wraylab:/hpc/group/wraylab docker://broadinstitute/gatk:4.1.3.0 gatk HaplotypeCallerSpark --input /work/kp275/clean_run_snp/${1}.bam.dedup.bam --output ${1}_spark.g.vcf --reference /work/sm997/gynandromorph_2024/raw_data/Heliconius_melpomene_melpomene_Hmel2.5.scaffolds.fa -ERC GVCF
singularity exec -B /hpc/group/wraylab:/hpc/group/wraylab docker://broadinstitute/gatk:4.1.3.0 gatk HaplotypeCallerSpark --input ./${1}.bam.dedup.bam --output ${1}_spark.g.vcf --reference /hpc/group/wraylab/kp275/Butterfly/Heliconius_melpomene_melpomene_Hmel2.5.scaffolds.fa -ERC GVCF

echo changing sample name of $1
sed -i s/Seq01/${1}/g ${1}_spark.g.vcf; done

echo zipping and indexing $1
bgzip ${1}_spark.g.vcf
tabix -p vcf ${1}_spark.g.vcf.gz
```


## <span style="font-size: 130%;"> STEP 4 Pt. 2: Joint Variant Calling </span>

Runs the script "joint_variant_calling" using the per sample VCFs created in the previous step.

```{r, eval = FALSE}
#!/bin/bash
#SBATCH --mem=100G
#SBATCH --cpus-per-task 24
#SBATCH --partition scavenger

singularity exec -B /hpc/group/wraylab:/hpc/group/wraylab docker://broadinstitute/gatk:4.1.3.0 gatk CombineGVCFs --reference /hpc/group/wraylab/kp275/Butterfly/Heliconius_melpomene_melpomene_Hmel2.5.scaffolds.fa --variant ${1}_spark.g.vcf.gz --variant ${2}_spark.g.vcf.gz --variant ${3}_spark.g.vcf.gz --variant ${4}_spark.g.vcf.gz -O cohort.g.vcf.gz
singularity exec -B /hpc/group/wraylab:/hpc/group/wraylab docker://broadinstitute/gatk:4.1.3.0 gatk GenotypeGVCFs --reference /hpc/group/wraylab/kp275/Butterfly/Heliconius_melpomene_melpomene_Hmel2.5.scaffolds.fa -V cohort.g.vcf.gz -O genotyped_cohort.vcf.gz

```


Here is a table summary of the VCFs before filtering:

![Before Filtering](images\before_filter.png)



## <span style="font-size: 130%;"> STEP 5: Variant Quality Control </span>

The main goal of Variant Quality Control is to filter the VCFs by removing indels and multiallelic sites, along with generating VCF stats and plots using BCFTools to ascertain filtering quality.


The following code is used in Step 5 of the pipeline using script "filter_vcfs.sh," with the joint called VCFs as the input file.

```{r, eval=FALSE}
#!/bin/sh
#SBATCH --mem=32G
#SBATCH --partition scavenger

input_vcf=$1
output_file="./filtered_vcfs/filtered_${input_vcf##*/}.vcf"
echo filtering $input_vcf ...

module load VCFtools/0.1.17
module load bcftools/1.4

# Keep only SNPs (remove indels)
bcftools filter -e 'TYPE!="snp"' $input_vcf > $output_file
bcftools stats $output_file > filtered_vcf_stats.txt
echo successfully removed indels and others, keeping only SNPs

#getting rid of missing positions
bcftools view --genotype ^miss $output_file -o ${output_file}_2
bcftools stats ${output_file}_2 > remove_missing_vcf_stats.txt
echo successfully removed missing position type

#remove fixed differences from reference
bcftools view --max-af 0.9:alt1 ${output_file}_2 -o ${output_file}_3
bcftools stats ${output_file}_3 > remove_fixeddifs_vcf_stats.txt
echo successfully removed fixed differences from reference

#remove multiallelic regions
bcftools view --max-alleles 2 ${output_file}_3 -o ${output_file}_4
bcftools stats ${output_file}_4 > remove_multiallelic_vcf_stats.txt
echo successfully removed multiallelic regions
```


Here is a summary table of the VCFs after filtering

![After Filtering](images\after_filter.png)


Now, only SNPs remain in the file. We have successfully reduced background noise in the joint-called VCF.




Once we split the joint-called VCF back into the 4 individual leg samples, we can perform further analysis on the SNP distribution. First, we created a global Manhattan Plot of the SNPs:


![Manhattan Plot](images\global snp plot.png)



From this, we can see that SNPs occur in the sex chromosomes as well as the autosomal chromosomes. Essentially, SNPs are present throughout the entire genome, not just the sex chromosomes.


This is another Manhattan plot that shows SNPs in just the three wing coloration genes of interest:

![Wing Manhattan Plot](images\wing_manhattan_plot.png)



Finally, here is a graph showing how many SNPs each of the four samples have in common:

![SNP Sharing Plot](images\snp_graph.png)

As we can see, the two combinations that share the most SNPs are R2 and R3, along with L2 and L3. This clearly shows that our gynandromorph has two separate genomes on its left and right sides.



<div id="refs"></div>
```{r Session Information}
sessionInfo()
```

